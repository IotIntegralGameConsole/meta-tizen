From: Ismo Puustinen <ismo.puustinen@intel.com>
Date: Tue, 27 May 2014 10:27:16 +0300
Subject: audio-groups: fix issues found by static analysis.

Change-Id: Ia2805a5977868b236bd6a33e7bc8fdcb944020ea
---
 src/modules/audio-groups/module-audio-groups.c | 63 ++++++++++++++++----------
 1 file changed, 40 insertions(+), 23 deletions(-)

diff --git a/src/modules/audio-groups/module-audio-groups.c b/src/modules/audio-groups/module-audio-groups.c
index 320847c..2b3a570 100644
--- a/src/modules/audio-groups/module-audio-groups.c
+++ b/src/modules/audio-groups/module-audio-groups.c
@@ -383,9 +383,13 @@ static bool match_predicate(struct literal *l, pas_stream *d) {
     else if (l->property_name && l->property_value) {
         /* check the property from the property list */
 
-        if (pa_proplist_contains(d->proplist, l->property_name) &&
-                strcmp(pa_proplist_gets(d->proplist, l->property_name), l->property_value) == 0)
-            return true;
+        if (pa_proplist_contains(d->proplist, l->property_name)) {
+            const char *prop = pa_proplist_gets(d->proplist, l->property_name);
+
+            if (prop && strcmp(prop, l->property_value) == 0) {
+                return true;
+            }
+        }
     }
 
     /* no match */
@@ -631,18 +635,8 @@ static struct expression_token *parse_rule_internal(const char *rule, bool disju
     char *p;
     int brace_count = 0;
     bool braces_present = false;
-    char left_buf[len];
-    char right_buf[len];
-
-#if 0
-    /* check if the rule is still valid */
-
-    if (len < 2)
-        return NULL;
-
-    if (rule[0] != '(' || rule[len-1] != ')')
-        return NULL;
-#endif
+    char left_buf[len+1];
+    char right_buf[len+1];
 
     et = pa_xnew0(struct expression_token, 1);
 
@@ -740,9 +734,9 @@ static struct expression_token *parse_rule_internal(const char *rule, bool disju
     else {
         /* this is a literal */
         char *begin_lit;
-        char buf[strlen(rule)+1];
-
+        char buf[len+1];
         struct literal_token *lit = pa_xnew0(struct literal_token, 1);
+
         if (!lit) {
             delete_expression_token(et);
             return NULL;
@@ -769,7 +763,8 @@ static struct expression_token *parse_rule_internal(const char *rule, bool disju
             *l = '\0';
         }
         else {
-            strncpy(buf, rule, sizeof(buf));
+            strncpy(buf, rule, len);
+            buf[len] = '\0';
         }
 
         if (strncmp(buf, "NEG", 3) == 0) {
@@ -782,6 +777,7 @@ static struct expression_token *parse_rule_internal(const char *rule, bool disju
         }
 
         lit->var = pa_xstrdup(begin_lit);
+
         et->lit = lit;
     }
 
@@ -869,8 +865,9 @@ static bool gather_conjunction(struct expression_token *et, struct conjunction *
 
     if (et->oper == operator_and) {
         if (!gather_conjunction(et->left, c) ||
-            !gather_conjunction(et->right, c))
+            !gather_conjunction(et->right, c)) {
             return false;
+        }
     }
     else {
         /* literal */
@@ -879,8 +876,13 @@ static bool gather_conjunction(struct expression_token *et, struct conjunction *
         if (!l)
             return false;
 
-        gather_literal(et, l);
+        if (!gather_literal(et, l)) {
+            pa_log_error("audio groups config: literal parsing failed");
+            delete_literal(l);
+            return false;
+        }
 
+        PA_LLIST_INIT(struct literal, l);
         PA_LLIST_PREPEND(struct literal, c->literals, l);
     }
 
@@ -897,9 +899,18 @@ static bool gather_expression(struct expression *e, struct expression_token *et)
     else {
         /* conjunction or literal */
         struct conjunction *c = pa_xnew0(struct conjunction, 1);
-        if (!gather_conjunction(et, c))
+
+        if (!c)
             return false;
 
+        PA_LLIST_HEAD_INIT(struct literal, c->literals);
+
+        if (!gather_conjunction(et, c)) {
+            delete_conjunction(c);
+            return false;
+        }
+
+        PA_LLIST_INIT(struct conjunction, c);
         PA_LLIST_PREPEND(struct conjunction, e->conjunctions, c);
     }
 
@@ -950,10 +961,16 @@ static struct expression *parse_rule(const char *rule_string) {
     if (!e)
         goto error;
 
+    PA_LLIST_HEAD_INIT(struct conjunction, e->conjunctions);
+
     /* gather expressions to actual match format */
-    gather_expression(e, et);
+    if (!gather_expression(e, et)) {
+        /* gathering the expression from tokens went wrong */
+        pa_log_error("failed to parse audio group stream classification data");
+        goto error;
+    }
 
-#if 1
+#if 0
     print_expression(e);
 #endif
 
