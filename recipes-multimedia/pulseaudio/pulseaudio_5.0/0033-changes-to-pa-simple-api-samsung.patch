From: "vivian,zhang" <vivian.zhang@intel.com>
Date: Tue, 18 Jun 2013 16:10:15 +0800
Subject: changes to pa simple api - samsung

Change-Id: I997c02217a8dc14524480164aa0baeea901c7b4e
Signed-off-by: Jaska Uimonen <jaska.uimonen@intel.com>
---
 src/Makefile.am    |   4 +-
 src/map-file       |   6 ++
 src/pulse/simple.c | 288 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/pulse/simple.h |  28 ++++++
 4 files changed, 324 insertions(+), 2 deletions(-)

diff --git a/src/Makefile.am b/src/Makefile.am
index 2edce5f..5ec8609 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -824,7 +824,7 @@ libpulse_la_SOURCES = \
 		pulse/volume.c pulse/volume.h \
 		pulse/xmalloc.c pulse/xmalloc.h
 
-libpulse_la_CFLAGS = $(AM_CFLAGS) $(LIBJSON_CFLAGS)
+libpulse_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS) $(LIBJSON_CFLAGS)
 libpulse_la_LIBADD = $(AM_LIBADD) $(WINSOCK_LIBS) $(LTLIBICONV) $(LIBJSON_LIBS) libpulsecommon-@PA_MAJORMINOR@.la
 libpulse_la_LDFLAGS = $(AM_LDFLAGS) $(VERSIONING_LDFLAGS) -version-info $(LIBPULSE_VERSION_INFO)
 
@@ -834,7 +834,7 @@ libpulse_la_LIBADD += $(DBUS_LIBS)
 endif
 
 libpulse_simple_la_SOURCES = pulse/simple.c pulse/simple.h
-libpulse_simple_la_CFLAGS = $(AM_CFLAGS)
+libpulse_simple_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
 libpulse_simple_la_LIBADD = $(AM_LIBADD) libpulse.la libpulsecommon-@PA_MAJORMINOR@.la
 libpulse_simple_la_LDFLAGS = $(AM_LDFLAGS) $(VERSIONING_LDFLAGS) -version-info $(LIBPULSE_SIMPLE_VERSION_INFO)
 
diff --git a/src/map-file b/src/map-file
index 7dbcd00..95364ae 100644
--- a/src/map-file
+++ b/src/map-file
@@ -282,11 +282,17 @@ pa_signal_new;
 pa_signal_set_destroy;
 pa_simple_drain;
 pa_simple_flush;
+pa_simple_mute;
 pa_simple_free;
 pa_simple_get_latency;
 pa_simple_new;
+pa_simple_new_proplist;
 pa_simple_read;
 pa_simple_write;
+pa_simple_set_volume;
+pa_simple_get_stream_index;
+pa_simple_cork;
+pa_simple_is_corked;
 pa_stream_begin_write;
 pa_stream_cancel_write;
 pa_stream_connect_playback;
diff --git a/src/pulse/simple.c b/src/pulse/simple.c
index 1891131..9109ffa 100644
--- a/src/pulse/simple.c
+++ b/src/pulse/simple.c
@@ -32,10 +32,12 @@
 #include <pulse/thread-mainloop.h>
 #include <pulse/xmalloc.h>
 
+#include <pulsecore/native-common.h>
 #include <pulsecore/log.h>
 #include <pulsecore/macro.h>
 
 #include "simple.h"
+#include "internal.h"
 
 struct pa_simple {
     pa_threaded_mainloop *mainloop;
@@ -102,6 +104,24 @@ static void context_state_cb(pa_context *c, void *userdata) {
     }
 }
 
+static void stream_success_context_cb(pa_stream *s, int success, void *userdata) {
+	pa_simple *p = userdata;
+	pa_assert(s);
+	pa_assert(p);
+
+    p->operation_success = success;
+    pa_threaded_mainloop_signal(p->mainloop, 0);
+}
+
+static void success_context_cb(pa_context *c, int success, void *userdata) {
+	pa_simple *p = userdata;
+	pa_assert(c);
+	pa_assert(p);
+
+    p->operation_success = success;
+    pa_threaded_mainloop_signal(p->mainloop, 0);
+}
+
 static void stream_state_cb(pa_stream *s, void * userdata) {
     pa_simple *p = userdata;
     pa_assert(s);
@@ -251,6 +271,122 @@ fail:
     return NULL;
 }
 
+pa_simple* pa_simple_new_proplist(
+        const char *server,
+        const char *name,
+        pa_stream_direction_t dir,
+        const char *dev,
+        const char *stream_name,
+        const pa_sample_spec *ss,
+        const pa_channel_map *map,
+        const pa_buffer_attr *attr,
+        pa_proplist *proplist,
+        int *rerror) {
+
+    pa_simple *p;
+    int error = PA_ERR_INTERNAL, r;
+
+    CHECK_VALIDITY_RETURN_ANY(rerror, !server || *server, PA_ERR_INVALID, NULL);
+    CHECK_VALIDITY_RETURN_ANY(rerror, dir == PA_STREAM_PLAYBACK || dir == PA_STREAM_RECORD, PA_ERR_INVALID, NULL);
+    CHECK_VALIDITY_RETURN_ANY(rerror, !dev || *dev, PA_ERR_INVALID, NULL);
+    CHECK_VALIDITY_RETURN_ANY(rerror, ss && pa_sample_spec_valid(ss), PA_ERR_INVALID, NULL);
+    CHECK_VALIDITY_RETURN_ANY(rerror, !map || (pa_channel_map_valid(map) && map->channels == ss->channels), PA_ERR_INVALID, NULL)
+
+    p = pa_xnew0(pa_simple, 1);
+    p->direction = dir;
+
+    if (!(p->mainloop = pa_threaded_mainloop_new()))
+        goto fail;
+
+    if (!(p->context = pa_context_new(pa_threaded_mainloop_get_api(p->mainloop), name)))
+        goto fail;
+
+    pa_context_set_state_callback(p->context, context_state_cb, p);
+
+    if (pa_context_connect(p->context, server, 0, NULL) < 0) {
+        error = pa_context_errno(p->context);
+        goto fail;
+    }
+
+    pa_threaded_mainloop_lock(p->mainloop);
+
+    if (pa_threaded_mainloop_start(p->mainloop) < 0)
+        goto unlock_and_fail;
+
+    for (;;) {
+        pa_context_state_t state;
+
+        state = pa_context_get_state(p->context);
+
+        if (state == PA_CONTEXT_READY)
+            break;
+
+        if (!PA_CONTEXT_IS_GOOD(state)) {
+            error = pa_context_errno(p->context);
+            goto unlock_and_fail;
+        }
+
+        /* Wait until the context is ready */
+        pa_threaded_mainloop_wait(p->mainloop);
+    }
+
+    if (!(p->stream = pa_stream_new_with_proplist(p->context, stream_name, ss, map, proplist))) {
+        error = pa_context_errno(p->context);
+        goto unlock_and_fail;
+    }
+
+    pa_stream_set_state_callback(p->stream, stream_state_cb, p);
+    pa_stream_set_read_callback(p->stream, stream_request_cb, p);
+    pa_stream_set_write_callback(p->stream, stream_request_cb, p);
+    pa_stream_set_latency_update_callback(p->stream, stream_latency_update_cb, p);
+
+    if (dir == PA_STREAM_PLAYBACK)
+        r = pa_stream_connect_playback(p->stream, dev, attr,
+                                       PA_STREAM_INTERPOLATE_TIMING
+                                       |PA_STREAM_ADJUST_LATENCY
+                                       |PA_STREAM_AUTO_TIMING_UPDATE, NULL, NULL);
+    else
+        r = pa_stream_connect_record(p->stream, dev, attr,
+                                     PA_STREAM_INTERPOLATE_TIMING
+                                     |PA_STREAM_ADJUST_LATENCY
+                                     |PA_STREAM_AUTO_TIMING_UPDATE
+                                     |PA_STREAM_START_CORKED);
+
+    if (r < 0) {
+        error = pa_context_errno(p->context);
+        goto unlock_and_fail;
+    }
+
+    for (;;) {
+        pa_stream_state_t state;
+
+        state = pa_stream_get_state(p->stream);
+
+        if (state == PA_STREAM_READY)
+            break;
+
+        if (!PA_STREAM_IS_GOOD(state)) {
+            error = pa_context_errno(p->context);
+            goto unlock_and_fail;
+        }
+
+        /* Wait until the stream is ready */
+        pa_threaded_mainloop_wait(p->mainloop);
+    }
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+    return p;
+
+unlock_and_fail:
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+fail:
+    if (rerror)
+        *rerror = error;
+    pa_simple_free(p);
+    return NULL;
+}
 void pa_simple_free(pa_simple *s) {
     pa_assert(s);
 
@@ -452,6 +588,111 @@ unlock_and_fail:
     return -1;
 }
 
+int pa_simple_mute(pa_simple *p, int mute, int *rerror) {
+    pa_operation *o = NULL;
+    uint32_t idx;
+
+    pa_assert(p);
+
+    CHECK_VALIDITY_RETURN_ANY(rerror, p->direction == PA_STREAM_PLAYBACK, PA_ERR_BADSTATE, -1);
+
+    pa_threaded_mainloop_lock(p->mainloop);
+    CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+
+    CHECK_SUCCESS_GOTO(p, rerror, ((idx = pa_stream_get_index (p->stream)) != PA_INVALID_INDEX), unlock_and_fail);
+
+
+    o = pa_context_set_sink_input_mute (p->context, idx, mute, success_context_cb, p);
+    CHECK_SUCCESS_GOTO(p, rerror, o, unlock_and_fail);
+
+    p->operation_success = 0;
+    while (pa_operation_get_state(o) == PA_OPERATION_RUNNING) {
+        pa_threaded_mainloop_wait(p->mainloop);
+        CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+    }
+    CHECK_SUCCESS_GOTO(p, rerror, p->operation_success, unlock_and_fail);
+
+    pa_operation_unref(o);
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+    return 0;
+
+unlock_and_fail:
+
+    if (o) {
+        pa_operation_cancel(o);
+        pa_operation_unref(o);
+    }
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+    return -1;
+}
+
+int pa_simple_get_stream_index(pa_simple *p, unsigned int *idx, int *rerror) {
+    pa_assert(p);
+    CHECK_VALIDITY_RETURN_ANY(rerror, idx != NULL, PA_ERR_INVALID, -1);
+
+    pa_threaded_mainloop_lock(p->mainloop);
+
+    CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+
+	*idx = pa_stream_get_index(p->stream);
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+    return 0;
+
+unlock_and_fail:
+    pa_threaded_mainloop_unlock(p->mainloop);
+    return -1;
+}
+
+int pa_simple_set_volume(pa_simple *p, int volume, int *rerror) {
+    pa_operation *o = NULL;
+    pa_stream *s = NULL;
+    uint32_t idx;
+    pa_cvolume cv;
+
+
+    pa_assert(p);
+
+    CHECK_VALIDITY_RETURN_ANY(rerror, p->direction == PA_STREAM_PLAYBACK, PA_ERR_BADSTATE, -1);
+    CHECK_VALIDITY_RETURN_ANY(rerror, volume >= 0, PA_ERR_INVALID, -1);
+    CHECK_VALIDITY_RETURN_ANY(rerror, volume <= 65535, PA_ERR_INVALID, -1);
+
+    pa_threaded_mainloop_lock(p->mainloop);
+    CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+
+    CHECK_SUCCESS_GOTO(p, rerror, ((idx = pa_stream_get_index (p->stream)) != PA_INVALID_INDEX), unlock_and_fail);
+
+    s = p->stream;
+    pa_assert(s);
+    pa_cvolume_set(&cv, s->sample_spec.channels, volume);
+
+    o = pa_context_set_sink_input_volume (p->context, idx, &cv, success_context_cb, p);
+    CHECK_SUCCESS_GOTO(p, rerror, o, unlock_and_fail);
+
+    p->operation_success = 0;
+    while (pa_operation_get_state(o) == PA_OPERATION_RUNNING) {
+        pa_threaded_mainloop_wait(p->mainloop);
+        CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+    }
+    CHECK_SUCCESS_GOTO(p, rerror, p->operation_success, unlock_and_fail);
+
+    pa_operation_unref(o);
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+    return 0;
+
+unlock_and_fail:
+
+    if (o) {
+        pa_operation_cancel(o);
+        pa_operation_unref(o);
+    }
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+    return -1;
+}
 pa_usec_t pa_simple_get_latency(pa_simple *p, int *rerror) {
     pa_usec_t t;
     int negative;
@@ -481,3 +722,50 @@ unlock_and_fail:
     pa_threaded_mainloop_unlock(p->mainloop);
     return (pa_usec_t) -1;
 }
+
+int pa_simple_cork(pa_simple *p, int cork, int *rerror) {
+    pa_operation *o = NULL;
+
+    pa_assert(p);
+
+    pa_threaded_mainloop_lock(p->mainloop);
+    CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+
+    o = pa_stream_cork(p->stream, cork, stream_success_context_cb, p);
+    CHECK_SUCCESS_GOTO(p, rerror, o, unlock_and_fail);
+
+    p->operation_success = 0;
+    while (pa_operation_get_state(o) == PA_OPERATION_RUNNING) {
+        pa_threaded_mainloop_wait(p->mainloop);
+        CHECK_DEAD_GOTO(p, rerror, unlock_and_fail);
+    }
+    CHECK_SUCCESS_GOTO(p, rerror, p->operation_success, unlock_and_fail);
+
+    pa_operation_unref(o);
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+    return 0;
+
+unlock_and_fail:
+
+    if (o) {
+        pa_operation_cancel(o);
+        pa_operation_unref(o);
+    }
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+    return -1;
+}
+
+int pa_simple_is_corked(pa_simple *p) {
+	int is_cork;
+    pa_assert(p);
+
+    pa_threaded_mainloop_lock(p->mainloop);
+
+    is_cork = pa_stream_is_corked(p->stream);
+
+    pa_threaded_mainloop_unlock(p->mainloop);
+
+    return is_cork;
+}
diff --git a/src/pulse/simple.h b/src/pulse/simple.h
index 54003ff..4f4a988 100644
--- a/src/pulse/simple.h
+++ b/src/pulse/simple.h
@@ -31,6 +31,7 @@
 #include <pulse/cdecl.h>
 #include <pulse/version.h>
 
+#include <pulse/proplist.h>
 /** \page simple Simple API
  *
  * \section overv_sec Overview
@@ -129,6 +130,19 @@ pa_simple* pa_simple_new(
     int *error                          /**< A pointer where the error code is stored when the routine returns NULL. It is OK to pass NULL here. */
     );
 
+/** Create a new connection to the server with proplist */
+pa_simple* pa_simple_new_proplist(
+    const char *server,                 /**< Server name, or NULL for default */
+    const char *name,                   /**< A descriptive name for this client (application name, ...) */
+    pa_stream_direction_t dir,          /**< Open this stream for recording or playback? */
+    const char *dev,                    /**< Sink (resp. source) name, or NULL for default */
+    const char *stream_name,            /**< A descriptive name for this client (application name, song title, ...) */
+    const pa_sample_spec *ss,           /**< The sample type to use */
+    const pa_channel_map *map,          /**< The channel map to use, or NULL for default */
+    const pa_buffer_attr *attr,         /**< Buffering attributes, or NULL for default */
+    pa_proplist *proplist,	/**< Properties, or NULL for default */
+    int *error                          /**< A pointer where the error code is stored when the routine returns NULL. It is OK to pass NULL here. */
+    );
 /** Close and free the connection to the server. The connection object becomes invalid when this is called. */
 void pa_simple_free(pa_simple *s);
 
@@ -155,6 +169,20 @@ pa_usec_t pa_simple_get_latency(pa_simple *s, int *error);
 
 /** Flush the playback or record buffer. This discards any audio in the buffer. */
 int pa_simple_flush(pa_simple *s, int *error);
+/** Mute the playback stream */
+int pa_simple_mute(pa_simple *p, int mute, int *rerror);
+
+/** Volume control the playback stream */
+int pa_simple_set_volume(pa_simple *p, int volume, int *rerror);
+
+/** Get stream index */
+int pa_simple_get_stream_index(pa_simple *p, unsigned int *idx, int *rerror);
+
+/** Cork on=1/off=0 stream */
+int pa_simple_cork(pa_simple *p, int cork, int *rerror);
+
+/** Check whether stream is corked or not */
+int pa_simple_is_corked(pa_simple *p);
 
 PA_C_DECL_END
 
